<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://sidnarsipur.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sidnarsipur.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-27T08:35:20+00:00</updated><id>https://sidnarsipur.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">intro to compilers optimizations (1)</title><link href="https://sidnarsipur.github.io/blog/2025/compiler/" rel="alternate" type="text/html" title="intro to compilers optimizations (1)"/><published>2025-02-26T23:12:00+00:00</published><updated>2025-02-26T23:12:00+00:00</updated><id>https://sidnarsipur.github.io/blog/2025/compiler</id><content type="html" xml:base="https://sidnarsipur.github.io/blog/2025/compiler/"><![CDATA[<p>Compilers can be considered the magicians of programming - they transform our ugly, slow source code into efficient &amp; speedy machine code.</p> <p>For most of the <a href="https://evansdata.com/reports/viewRelease.php?reportID=9">30 million software</a> developers in the world, the compiler is a black box - just another command to type out in the terminal. Many newer programmers will have never even typed out <code class="language-plaintext highlighter-rouge">gcc</code> or <code class="language-plaintext highlighter-rouge">javac</code> in the terminal and just press the ▶️ button in their IDEs.</p> <p>Understanding the compiler can help you write better code, and develop appreciate a fresh outlook on how code works. It’s not magic, just mechanical!</p> <h1 id="parsing--lexing">Parsing &amp; Lexing</h1> <p>Setting up the parse tree, according to me, is the boring part of compilation! Most of the interesting analysis and transformation happens after the creation of an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.</p> <p><br/></p> <div align="center"> <img src="https://i.sstatic.net/Xik2j.png" alt="Abstract syntax tree for Euclidean algorithm" width="50%"/> <h6>Credit: Wikimedia Commons</h6> </div> <p><br/></p> <p>The AST is the first of many structures that represent source code as a graph. Representing code as a graph is a really powerful tool that will let us reason about control flow and the state of our program (more on this later).</p> <p>This blog will mainly focus on the middle end of the compiler.</p> <h1 id="intermediate-representation">Intermediate Representation</h1> <p>Once the AST has been created, it is lowered into an intermediate representation (IR). There are multiple IRs used in a compiler, with each offering different benefits and drawbacks for analysis.</p> <p>Using an IR allows multiple programming languages to use the same compiler for middle end optimizations and code generation, or combine different front ends and back ends together.</p> <p><br/></p> <div align="center"> <img src="https://liucs.net/cs664s16/compiler-front-back.png" alt="Abstract syntax tree for Euclidean algorithm" width="50%"/> <h6>Credit: https://liucs.net/cs664s16/ir.html</h6> </div> <p><br/></p> <p>IRs simplify code analysis by adding information about control flow or variable mutation. IRs are also linear and eliminate the need to recursively visit an AST (flattening).</p> <p>In this blog we’ll look at two popular IRs - three address code and control flow graphs.</p> <h1 id="three-address-code">Three Address Code</h1> <p>The IR in compilers tries to maintain simplicity in their instructions, and does not support complex data structures or control flow like source code does.</p> <p>One of the most popular IRs is three address code, where each instruction is an operation upon two operands.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>z = x op y (General form)

z = x + 3
z = x * 3
</code></pre></div></div> <p>Three address code in real compilers may look something like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%z = add i32 %x, 3
</code></pre></div></div> <p>Longer expressions</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>z = ((x * y) + (2 * z)) / (1+n)
</code></pre></div></div> <p>can also easily be translated into three address form by introducing temporaries:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t0 = x * y
t1 = 2 + z
t2 = t0 + t1
t3 = 1 + n
z = t2 / t3
</code></pre></div></div> <p>The process of generating three address code from an AST is mechanical and can be done through a tree traversal.</p> <p>What about branching and conditional flow? By only introducing goto and label statements, we can handle for loops, if statements, etc.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(x &gt; 10){
    y = 10
} else {
    y = 5
}
</code></pre></div></div> <p>becomes</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start:
    t0 = x &gt; 10
    if t0 == 0: goto else
    y = 10
    goto exit
else:
    y = 5
    goto exit
exit:
</code></pre></div></div> <p>For loops like</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(int i = 0; i &lt;= 5; i++){
    x = x + 1;
}

y = 10

</code></pre></div></div> <p>becomes</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = 0

condition:
    t0 = i &lt;= 5
    if t0 == 0: goto exit
    goto body

body:
    x = x + 1
    i = i + 1
    goto condition

exit:
    y = 10
</code></pre></div></div> <h1 id="control-flow-graphs">Control Flow Graphs</h1> <p>Control Flow Graphs (CFGs) are the most common form of IRs used in analysis.</p> <div align="center"> <img src="https://www.cs.toronto.edu/~david/course-notes/csc110-111/17-graphs/images/one-iteration-simple.svg" alt="Abstract syntax tree for Euclidean algorithm" width="50%"/> <h6>Credit: https://www.cs.toronto.edu/~david</h6> </div> <p>Each node is a CFG is a <em>basic block</em>, the smallest unit of linear code without branches in or out (single entry, single exit).</p> <p>For example,</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(x &gt; 10){
    y = 10
    z = 25
} else{
    y = 20
    z = 40
}

l = 100
</code></pre></div></div> <p>consists of three basic blocks:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BB001:
    t0 = x &gt; 10
    if t0 == 0: goto BB002
    y = 10
    z = 25
    goto EXIT

BB002:
    y = 20
    z = 40
    goto BB003

BB003:
    l = 100
</code></pre></div></div> <p>BB003 in the above example is called a <em>join node</em>, a node with more than incoming edge. Join nodes are harder to reason about, as they indicate that the program could have taken multiple different routes to get there. Some IRs like <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">SSA form</a> make analysis on join nodes easier to perform.</p> <p>Edges in CFGs indicate transfers in the flow of execution and can help us reason about the state of a program at a particular point. Reasoning about our code as a graph leads to dataflow analysis, which I will discuss in the next blog post.</p> <p>Thank you for reading!</p> <p>Discalimer: I am not an expert in compilers, and just want to share some cool ideas I’ve been learning. If I’ve made an error somewhere, <a href="mailto:sid.narsipur@gmail.com">let me know</a>.</p>]]></content><author><name></name></author><category term="cs"/><summary type="html"><![CDATA[Compilers can be considered the magicians of programming - they transform our ugly, slow source code into efficient &amp; speedy machine code.]]></summary></entry></feed>